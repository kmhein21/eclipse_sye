---
title: "Write Up"
format: html
---

### Methods (Erika): 

We collected data between March 30 and April XX, 2024 by deploying 20 AudioMothTM acoustic recorders throughout St. Lawrence County, New York. All locations were fully within the path of totality for the April 8, 2024 total solar eclipse. The partial eclipse began at 14:11:38, totality began at 15:23:52, maximum eclipse was at 15:25:29, totality ended at 15:27:05 and the partial eclipse ended at 16:35:38 (all times local, times from https://www.timeanddate.com/eclipse/in/@5111484?iso=20240408) for a total eclipse duration of 2 hours 24 minutes with totality lasting 3 minutes and 13 seconds.  

Each AudioMoth was configured to record within four temporal windows on each day of the deployment. The first window was from 05:45 – 07:15 (approximately 30 minutes before to 45 minutes after sunrise), the second from 14:00 to 16:50 (capturing the full period of time each day corresponding to the eclipse on April 8),  third from 19:00 to 20:00 (approximately 30 minutes before and after sunset) and the last from 23:00 to 23:30 (to sample nocturnal sounds). (Table 1.)

#### Table 1. 

```{r}
library(pander)
Times<- c("05:45 - 07:15", "14:00 - 16:50", "19:00- 20:00", "23:00 - 23:30")

Reasoning<- c("30-45 minutes before sunrise", "full period of time corresponding to the eclipse", "~30 minutes before and after sunset", "sample nocturnal activity")

Table1<-cbind(Times, Reasoning)
Table1|>pander()
```


Within each time window, each AudioMoth recorded in a repeated cycle with 55 seconds of recording and 5 seconds to write data for every minute of the recording window (Table 2). Sample rate measures the density of recordings per unit time and therefore the range of frequencies that can be recorded. High sample rates record a higher range of frequencies but take up more space on the microSD card. We selected a sample rate of 96 kHz to capture sound frequencies up to about 48 kHz, which allowed us to capture common bird and amphibian songs and calls as well as at least some insects and bat echolocation sounds. Gain is a measure of the degree to which the microphone amplifies the sound as it is recorded. Higher gain enables detection of quieter sounds but can also result in clipping and distortion. After collecting pilot recordings near wetlands where wood frogs were calling we determined that a gain setting of 4 would help increase our detection of animal sounds. 

#### Table 2. 

```{r}
Parameters<- c("Sample Rate (kHz)", "Gain", "Sleep duration (seconds)", "Recording duration (seconds)")

Setting<-c("96", "Relatively high (4 on a 5 point scale)", "5", "55")

Table2<-cbind(Parameters, Setting)
Table2|> pander()
```



We used ArcGIS Pro (version XXXX, ESRI Incorporated, Redlands, California) to identify areas of forest-wetland interface or forested wetland occurring on public or University-owned land. Our intention was to place the recorders at locations where they could capture the sounds of both forest birds and pond-breeding amphibians (as well as other biotic sounds including any active insects or bats). Due to our northern location within the path of the eclipse in North America, the onset of spring was just beginning. Red-winged blackbirds (Agelaius phoeniceus) had returned to the area and were establishing breeding territories and both wood frogs (Lithobates sylvaticus) and spring peepers (Pseudacris crucifer) had begun to chorus at least 5 days prior to deployment of the recorders. To reduce the time required to deploy units, we located the devices near but out of view of hiking trails and within 20 miles of the St. Lawrence University campus (44.58931027483651º N, -75.1613716006626 º W). 


### Analysis

The analysis of this data uses many packages included "Tidyverse", "hms", "soundecology", "here", and "tuneR"

Using the $'soundecology'$ package we selected 5 specific indices of interest that we believed would be important in understanding the changes in acoustic activity. For all the functions used a specific numerical value was obtained as data was only available for the left channel of the recorder. 
Acoustic Evenness Index:

Index which measures the equality and inequality of sound power distribution in different ranges. This index uses the Gini index of evenness. This index is found using the acoustic_evenness() function in the soundecology package. The specific numerical value used is from subsetting $aei_left. 

Bioacoustic Evenness Index:

Index is a function of the power and freqeuncy range of biotic sound. This is obtained using the bioacoustic_evenness() function in the soundecology package. The specific numerical value used is from subsetting $left_area.  

Acoustic Diverstiy Index:

Index which generates proportions of data within a specific interval that reach above a specified threshold (default -50dBFS). This index is obtained using the acoustic_diversity() function in the soundecology package. The specific numerical value used is from subsetting $left_band_values.  

Acoustic Complexity Index:

Index is a function of the amount of variation within frequency bins of a sample. This index is obtained using the acoustic_complexity() function within the soundecology package. The specific numerical value used is from subsetting $acl_left_vals.  

Biophony: 

Index which calculates the average frequency of biotic sound. This index is obtained as a byproduct from the ndsi() function and the numerical values used is from subsetting $biophony_left. 

Initially the goal was to create a data frame that contained all of the information about the indices that we would like to assess. This allowed us to visualize the indices in graphics and we began with a subset of 10 audiofiles (.WAV). Examples of some of the initial graphs are listed below: 
```{r}
ggplot(data=New_First10_df, aes(x=time, y=as.numeric(BEI)))+
  geom_line(col="orange")+
  theme_minimal()+
  labs(x = "Time", y = "Bioacoustic Evenness")

ggplot(data=New_First10_df, aes(x = time, y = as.numeric(AEI)))+
  geom_line()+
  theme_minimal()+
  labs(x = "Time", y = "Acoustic Evenness")

ggplot(data = New_First10_df, aes(x = time, y = as.numeric(Biophony)))+
  geom_line(col = "green")+
  theme_minimal()+
  labs(x = "Time", y = "Biophony")

```

The next step was to increase this creating  a function $eclipse_df()$ that could be used on a folder containing all of the .WAV files for one audiomoth which would return a cleaned data frame which could be manipulated. The goal was to create this function so that it could be uploaded to an HPC and mapped onto all the audiomoth folders that we had access to. In the function this requires saving single indices as one value per file in a column, and saving lists of values as a column for indices such as Acoustic complexity and diversity, which possessed multiple values per recording. Initially this function was used on two folders of audiomoths from April 7th and 8th to create some comparison visuals before we expanded the project to the full set of data we had access to. 

 
```{r}
## Fix these graphs so the x-axis is only time, not date as well 
New_df_4_7
New_df_4_8


ggplot(data = both_days, aes(x = time, y = Biophony, color = day))+
  geom_line()+
  scale_color_viridis_d()+
  theme_minimal()+
  labs(title = "Biophony")

ggplot(data = both_days, aes(x = only_time, y = AEI, color = day))+
  geom_line()+
  scale_color_viridis_d()+
  theme_minimal()+
  labs(title = "Acoustic Evenness")

ggplot(data = both_days, aes(x = only_time, y = BEI, color = day))+
  geom_line()+
    scale_color_viridis_d()+
  theme_minimal()+
  labs(title = "Bioacoustic Evenness")
```

The final step of the function as mentioned before is to create a fully cleaned data frame. Along with the single and multiple sound indices a column was added depicting the data and time, as well as the name of the folder the data came from (note this was not included in the above comparison of 4/7/24 and 4/8/24). The code for this data frame is listed below:

```{r}
full|> mutate(biophony = as.numeric(biophony),
                        aei = as.numeric(aei),
                        bei = as.numeric(bei))|>
    separate(paths_date, into = c("date","time_hms"), sep = "_")|>
    separate(time_hms, into = c("time", "wav"), sep = "\\.")|>
    separate(time, into = c("hours", "other"), sep = 2)|>
    separate(other, into = c("min", "sec"), sep = 2)|>
    mutate(date = parse_number(date))|>
    unite("time", c("date", "hours", "min", "sec"), sep = ":")|>
    mutate(time= ymd_hms(time))|>
    select(-wav)|>
    mutate(folder_name = deparse(str_remove(folder, here())))|>
    select(folder_name, everything())
```

The final output of this function is the creation of an RDS file that can be renamed upon loading into the environment. 












